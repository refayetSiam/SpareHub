import { Bus, BusType, Component, ComponentPosition, ComponentStatus, WorkOrder, MaintenanceHistory } from '@/types';
import { COMPONENT_MASTERS, GARAGES } from './constants';

// Helper functions
function randomBetween(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomDateBetween(start: Date, end: Date): Date {
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
}

function extractPosition(type: string): ComponentPosition {
  if (type.includes('_fl')) return 'FL';
  if (type.includes('_fr')) return 'FR';
  if (type.includes('_rl')) return 'RL';
  if (type.includes('_rr')) return 'RR';
  return 'N/A';
}

function generateRandomCoordinates(garageId: string): { lat: number; lng: number } {
  const garage = GARAGES.find(g => g.id === garageId);
  if (!garage) return { lat: 40.7350, lng: -73.9485 };

  // Generate random coordinates within ~5km radius of garage
  const latOffset = (Math.random() - 0.5) * 0.09; // ~5km
  const lngOffset = (Math.random() - 0.5) * 0.09;

  return {
    lat: garage.coordinates.lat + latOffset,
    lng: garage.coordinates.lng + lngOffset
  };
}

function generateComponents(currentMileage: number, registrationDate: Date): Component[] {
  const components: Component[] = [];

  COMPONENT_MASTERS.forEach(master => {
    // Randomly determine how much of the component's lifetime has been used
    const usagePercent = Math.random() * 1.5; // 0% to 150% (more overdue components)
    const mileageSinceInstalled = master.defaultLifetimeKm * usagePercent;
    const installedMileage = Math.max(0, currentMileage - mileageSinceInstalled);

    // Calculate status based on usage
    let status: ComponentStatus;
    if (usagePercent > 1.1) status = 'overdue';
    else if (usagePercent > 0.9) status = 'critical';
    else if (usagePercent > 0.7) status = 'warning';
    else status = 'good';

    // Calculate installation date based on mileage (assuming 50km/day average)
    const daysAgo = mileageSinceInstalled / 50;
    const installedDate = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000);

    // Calculate renewal date
    const daysUntilRenewal = (master.defaultLifetimeKm - mileageSinceInstalled) / 50;
    const renewalDate = new Date(Date.now() + daysUntilRenewal * 24 * 60 * 60 * 1000);

    components.push({
      id: `comp-${Math.random().toString(36).substr(2, 9)}`,
      type: master.type,
      position: master.requiresPosition ? extractPosition(master.type) : 'N/A',
      installedDate: installedDate.toISOString(),
      lifetimeKm: master.defaultLifetimeKm,
      renewalDate: renewalDate.toISOString(),
      estimatedCost: Math.round(master.averageCost * randomBetween(90, 110) / 100),
      currentMileage: installedMileage,
      status
    });
  });

  return components;
}

function generateWorkOrder(bus: Bus, components: Component[]): WorkOrder {
  const priority = components.some(c => c.status === 'overdue') ? 'critical' as const :
    components.some(c => c.status === 'critical') ? 'high' as const :
    'medium' as const;

  const estimatedCost = components.reduce((sum, c) => sum + c.estimatedCost, 0);

  return {
    id: `wo-${Math.random().toString(36).substr(2, 9)}`,
    busId: bus.id,
    garageId: bus.garageId,
    title: `Component Replacement - ${bus.vehicleNumber}`,
    description: `Scheduled maintenance for ${components.map(c => c.type).join(', ')}`,
    components: components.map(c => c.type),
    priority,
    status: 'pending',
    createdDate: new Date().toISOString(),
    estimatedCost,
    notes: '',
    isAutoGenerated: true
  };
}

function generateBus(index: number, garageId: string, prefix: string): Bus {
  const busTypes: BusType[] = ['Standard', 'Articulated', 'Double-Decker', 'Mini'];
  const type = busTypes[Math.floor(Math.random() * busTypes.length)];

  const capacityMap: Record<BusType, number> = {
    'Standard': 40,
    'Articulated': 60,
    'Double-Decker': 80,
    'Mini': 25
  };
  const capacity = capacityMap[type];

  const registrationDate = randomDateBetween(
    new Date('2015-01-01'),
    new Date('2023-01-01')
  );

  const currentMileage = randomBetween(50000, 300000);
  const components = generateComponents(currentMileage, registrationDate);

  return {
    id: `bus-${String(index).padStart(3, '0')}`,
    vehicleNumber: `TL-${prefix}-${String(index).padStart(3, '0')}`,
    type,
    capacity,
    status: 'active',
    garageId,
    currentMileage,
    registrationDate: registrationDate.toISOString(),
    lastMaintenanceDate: randomDateBetween(
      new Date(Date.now() - 90 * 24 * 60 * 60 * 1000),
      new Date()
    ).toISOString(),
    components,
    additionalMaintenanceItems: [],
    coordinates: generateRandomCoordinates(garageId)
  };
}

export function generateFleetData(): {
  buses: Bus[];
  workOrders: WorkOrder[];
  maintenanceHistory: MaintenanceHistory[];
} {
  const buses: Bus[] = [];
  const workOrders: WorkOrder[] = [];
  const maintenanceHistory: MaintenanceHistory[] = [];

  // North Garage: 17 buses
  for (let i = 1; i <= 17; i++) {
    const bus = generateBus(i, 'garage-north', 'N');
    buses.push(bus);

    // Generate work orders for overdue/critical components
    const needsMaintenance = bus.components.filter(
      c => c.status === 'overdue' || c.status === 'critical'
    );
    if (needsMaintenance.length > 0) {
      workOrders.push(generateWorkOrder(bus, needsMaintenance));
    }
  }

  // South Garage: 12 buses
  for (let i = 18; i <= 29; i++) {
    const bus = generateBus(i, 'garage-south', 'S');
    buses.push(bus);

    const needsMaintenance = bus.components.filter(
      c => c.status === 'overdue' || c.status === 'critical'
    );
    if (needsMaintenance.length > 0) {
      workOrders.push(generateWorkOrder(bus, needsMaintenance));
    }
  }

  // Ensure 5-7 buses are in maintenance
  const maintenanceCount = randomBetween(5, 7);
  const busesToMaintain = buses
    .sort(() => Math.random() - 0.5)
    .slice(0, maintenanceCount);

  busesToMaintain.forEach(bus => {
    bus.status = 'maintenance';
    // Add estimated active date 7-30 days from now
    const daysUntilActive = randomBetween(7, 30);
    bus.estimatedActiveDate = new Date(Date.now() + daysUntilActive * 24 * 60 * 60 * 1000).toISOString();
  });

  // Set 2-3 buses as decommissioned with estimated active dates
  const decommissionedCount = randomBetween(2, 3);
  const busesToDecommission = buses
    .filter(b => b.status === 'active')
    .sort(() => Math.random() - 0.5)
    .slice(0, decommissionedCount);

  busesToDecommission.forEach(bus => {
    bus.status = 'decommissioned';
    // Add estimated active date 30-90 days from now
    const daysUntilActive = randomBetween(30, 90);
    bus.estimatedActiveDate = new Date(Date.now() + daysUntilActive * 24 * 60 * 60 * 1000).toISOString();
  });

  return { buses, workOrders, maintenanceHistory };
}
