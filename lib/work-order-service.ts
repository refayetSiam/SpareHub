import { Bus, Component, WorkOrder, ComponentType, AdditionalMaintenanceItem } from '@/types';
import { LocalStorageService } from './storage';
import { COMPONENT_MASTERS, MECHANICS } from './constants';

function getComponentDisplayName(type: string): string {
  const master = COMPONENT_MASTERS.find(m => m.type === type);
  return master?.displayName || type;
}

// Counter for round-robin mechanic assignment
let mechanicAssignmentIndex = 0;

function getNextMechanic(): string {
  const mechanic = MECHANICS[mechanicAssignmentIndex % MECHANICS.length];
  mechanicAssignmentIndex++;
  return mechanic.name;
}

/**
 * Generate work orders for components that are not in good status
 * Creates ONE work order per component (1:1 relationship)
 */
export function generateWorkOrdersForBus(bus: Bus): WorkOrder[] {
  const workOrders: WorkOrder[] = [];

  // Get existing work orders for this bus
  const existingWorkOrders = LocalStorageService.getWorkOrders().filter(
    wo => wo.busId === bus.id && (wo.status === 'pending' || wo.status === 'in_progress')
  );

  // Create ONE work order per component that needs maintenance (1:1 relationship)
  bus.components.forEach(component => {
    if (component.status === 'overdue' || component.status === 'critical' || component.status === 'warning') {
      // Check if work order already exists for this specific component
      const existsForComponent = existingWorkOrders.some(wo =>
        wo.components.includes(component.type) && wo.components.length === 1
      );

      if (!existsForComponent) {
        const priority = component.status === 'overdue' ? 'critical' as const :
                        component.status === 'critical' ? 'high' as const :
                        'medium' as const;

        const displayName = getComponentDisplayName(component.type);

        const workOrder: WorkOrder = {
          id: `wo-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          busId: bus.id,
          garageId: bus.garageId,
          title: `${displayName} Maintenance - ${bus.vehicleNumber}`,
          description: `Scheduled maintenance for ${displayName}. Component has reached ${component.status} status and requires attention.`,
          components: [component.type],
          priority,
          status: 'pending',
          createdDate: new Date().toISOString(),
          dueDate: component.renewalDate, // Due date based on component renewal date
          estimatedCost: component.costOverride || component.estimatedCost,
          notes: `Auto-generated work order for ${component.status} component.`,
          isAutoGenerated: true,
          assignedMechanic: getNextMechanic()
        };

        workOrders.push(workOrder);
      }
    }
  });

  return workOrders;
}

/**
 * Generate work orders for additional maintenance items
 * Creates ONE work order per maintenance item that needs attention
 */
export function generateWorkOrdersForMaintenanceItems(bus: Bus): WorkOrder[] {
  const workOrders: WorkOrder[] = [];

  // Get existing work orders for this bus
  const existingWorkOrders = LocalStorageService.getWorkOrders().filter(
    wo => wo.busId === bus.id && (wo.status === 'pending' || wo.status === 'in_progress')
  );

  bus.additionalMaintenanceItems?.forEach(item => {
    if (item.status !== 'good') {
      // Check if work order already exists for this maintenance item
      const existsForItem = existingWorkOrders.some(wo =>
        wo.maintenanceItemId === item.id
      );

      if (!existsForItem) {
        const priority = item.status === 'overdue' ? 'critical' as const :
                        item.status === 'critical' ? 'high' as const :
                        'medium' as const;

        workOrders.push({
          id: `wo-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          busId: bus.id,
          garageId: bus.garageId,
          title: `${item.description} - ${bus.vehicleNumber}`,
          description: item.description,
          components: [],
          priority,
          status: 'pending',
          createdDate: new Date().toISOString(),
          dueDate: item.renewalDate, // Due date based on maintenance item renewal date
          estimatedCost: item.cost,
          notes: item.notes || '',
          isAutoGenerated: true,
          maintenanceItemId: item.id,
          assignedMechanic: getNextMechanic()
        });
      }
    }
  });

  return workOrders;
}

/**
 * Complete a work order and update the associated components
 * This resets the component installed dates and recalculates renewal dates
 */
export function completeWorkOrder(
  workOrderId: string,
  actualCost: number,
  completedComponents: ComponentType[],
  notes?: string
): { success: boolean; message: string } {
  try {
    const workOrder = LocalStorageService.getWorkOrder(workOrderId);
    if (!workOrder) {
      return { success: false, message: 'Work order not found' };
    }

    if (workOrder.status === 'completed') {
      return { success: false, message: 'Work order already completed' };
    }

    const bus = LocalStorageService.getBus(workOrder.busId);
    if (!bus) {
      return { success: false, message: 'Bus not found' };
    }

    // Update work order
    const updatedWorkOrder: WorkOrder = {
      ...workOrder,
      status: 'completed',
      completedDate: new Date().toISOString(),
      actualCost,
      notes: notes || workOrder.notes
    };

    // Update components that were completed
    const completionDate = new Date().toISOString();
    const updatedComponents = bus.components.map(comp => {
      if (completedComponents.includes(comp.type)) {
        const master = COMPONENT_MASTERS.find(m => m.type === comp.type);
        if (!master) return comp;

        // Reset component with new installed date
        const newInstalledDate = completionDate;
        const lifetimeInDays = master.defaultLifetimeKm / 50; // Assuming 50km/day average
        const renewalDate = new Date(Date.now() + lifetimeInDays * 24 * 60 * 60 * 1000).toISOString();

        return {
          ...comp,
          installedDate: newInstalledDate,
          renewalDate: renewalDate,
          currentMileage: bus.currentMileage,
          status: 'good' as const
        };
      }
      return comp;
    });

    // Update bus with new component dates and last maintenance date
    const updatedBus: Bus = {
      ...bus,
      components: updatedComponents,
      lastMaintenanceDate: completionDate
    };

    // Save updates
    LocalStorageService.updateWorkOrder(workOrderId, updatedWorkOrder);
    LocalStorageService.updateBus(bus.id, updatedBus);

    // Create maintenance history record
    completedComponents.forEach(componentType => {
      const component = updatedComponents.find(c => c.type === componentType);
      if (component) {
        LocalStorageService.addMaintenanceHistory({
          id: `mh-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          busId: bus.id,
          workOrderId: workOrder.id,
          componentType: component.type,
          action: 'replaced',
          date: completionDate,
          cost: actualCost / completedComponents.length, // Divide cost equally
          mechanicName: workOrder.assignedMechanic || 'Unassigned',
          notes: notes || ''
        });
      }
    });

    return { success: true, message: 'Work order completed successfully' };
  } catch (error) {
    console.error('Error completing work order:', error);
    return { success: false, message: 'Failed to complete work order' };
  }
}

/**
 * Check all buses and generate work orders for components needing maintenance
 * This should be run periodically or when component status changes
 */
export function generateAllWorkOrders(): number {
  const buses = LocalStorageService.getBuses();
  let totalGenerated = 0;

  buses.forEach(bus => {
    const newWorkOrders = generateWorkOrdersForBus(bus);
    newWorkOrders.forEach(wo => {
      LocalStorageService.addWorkOrder(wo);
      totalGenerated++;
    });
  });

  return totalGenerated;
}

/**
 * Update component status when it's manually changed
 * This may trigger new work order generation
 */
export function handleComponentStatusChange(busId: string, componentId: string): void {
  const bus = LocalStorageService.getBus(busId);
  if (!bus) return;

  const component = bus.components.find(c => c.id === componentId);
  if (!component) return;

  // If component is no longer good, generate work order if needed
  if (component.status !== 'good') {
    const newWorkOrders = generateWorkOrdersForBus(bus);
    newWorkOrders.forEach(wo => LocalStorageService.addWorkOrder(wo));
  }
}
